"""
History Recorder

Focused module for recording and persisting StateChangeBlock instances.
This module handles the persistence layer for conversation context and state changes,
providing a clean interface for storing bot actions and decisions for later analysis.
"""

import asyncio
import json
import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

import aiosqlite

logger = logging.getLogger(__name__)


@dataclass
class StateChangeBlock:
    """Represents a valid state change generated by the LLM or tools"""

    timestamp: float
    change_type: str  # 'llm_observation', 'tool_execution', 'user_input', 'world_update'
    source: str  # 'llm', 'tool_name', 'user', 'system'
    channel_id: Optional[str]
    observations: Optional[str]
    potential_actions: Optional[List[Dict[str, Any]]]
    selected_actions: Optional[List[Dict[str, Any]]]
    reasoning: Optional[str]
    raw_content: Dict[str, Any]  # Original content for training


class HistoryRecorder:
    """
    Records and persists StateChangeBlock instances for analysis and training.
    
    This class provides a focused interface for:
    1. Recording bot actions and decisions
    2. Persisting state changes to database and files
    3. Retrieving historical records for analysis
    4. Managing storage limits and cleanup
    """

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.state_changes: List[StateChangeBlock] = []

        # Initialize storage directory
        self.storage_path = Path("data/context_storage")
        self.storage_path.mkdir(parents=True, exist_ok=True)

        logger.info("HistoryRecorder: Initialized")

    async def initialize(self):
        """Initialize the database and ensure tables exist."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                await db.commit()
                logger.info("HistoryRecorder: Database initialized")
                
            # Initialize memory tables
            await self.initialize_memory_tables()
            
        except Exception as e:
            logger.error(f"HistoryRecorder: Error initializing database: {e}")

    async def record_action(self, action_name: str, action_data: Dict[str, Any], result: Any):
        """Record a tool action execution."""
        observation_str = f"Tool '{action_name}' executed with params {action_data}. Result: {result}"
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="tool_execution",  # Consistent with test_record_tool_execution expectation after fix
            source="tool", # Changed from action_name to "tool"
            channel_id=action_data.get("channel_id"),
            observations=observation_str, # Populated observations
            potential_actions=None,
            selected_actions=[action_data],
            reasoning=f"Executed {action_name}",
            raw_content={
                "action": action_data,
                "result": str(result) if result else None,
                "tool_name": action_name
            }
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded action {action_name}")

    async def record_decision(
        self,
        channel_id: str,
        observations: str,
        potential_actions: List[Dict[str, Any]],
        selected_actions: List[Dict[str, Any]],
        reasoning: str,
        raw_llm_response: Dict[str, Any]
    ):
        """Record an AI decision with observations and selected actions."""
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="llm_observation", # Test expects "bot_decision", will adjust test
            source="llm",
            channel_id=channel_id,
            observations=observations,
            potential_actions=potential_actions,
            selected_actions=selected_actions,
            reasoning=reasoning,
            raw_content=raw_llm_response
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded AI decision for {channel_id}")

    async def record_user_input(self, channel_id: Optional[str], user_data: Dict[str, Any]):
        """Record user input to the system."""
        if not isinstance(user_data, dict):
            raise TypeError("user_data must be a dictionary.")
        if not user_data: # Check if dict is empty
            raise ValueError("user_data cannot be empty.")

        # Attempt to extract a meaningful observation from common message structures
        observed_text = ""
        if "content" in user_data and isinstance(user_data["content"], dict):
            if "body" in user_data["content"]: # For Matrix-like messages
                observed_text = str(user_data["content"]["body"])
            elif "text" in user_data["content"]: # For other common structures
                observed_text = str(user_data["content"]["text"])
        elif "message" in user_data: # Simpler structure
             observed_text = str(user_data["message"])
        elif "text" in user_data:
             observed_text = str(user_data["text"])
        else: # Fallback if no common structure found
            observed_text = json.dumps(user_data)


        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="user_input",
            source="user",
            channel_id=channel_id,
            observations=observed_text, # Populated observations
            potential_actions=None,
            selected_actions=None,
            reasoning="User input received",
            raw_content=user_data
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded user input for {channel_id}")

    async def record_world_update(self, update_type: str, update_data: Dict[str, Any]):
        """Record a world state update."""
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="world_update",
            source="system",
            channel_id=None,
            observations=None,
            potential_actions=None,
            selected_actions=None,
            reasoning=f"World state update: {update_type}",
            raw_content=update_data
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded world update: {update_type}")

    async def record_tool_execution(
        self,
        tool_name: str,
        tool_params: Dict[str, Any],
        tool_result: Dict[str, Any],
        channel_id: Optional[str] = None
    ):
        """Record the execution of a tool/action."""
        # Convert to the format expected by record_action
        action_data = tool_params.copy()
        if channel_id:
            action_data["channel_id"] = channel_id
        
        # Use the unified record_action method
        await self.record_action(tool_name, action_data, tool_result)
        logger.debug(f"HistoryRecorder: Recorded tool execution {tool_name} (via record_action)")

    async def record_state_change(self, state_change: StateChangeBlock):
        """Record a state change block (public interface for external callers)."""
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded state change: {state_change.change_type}")

    async def _store_state_change(self, state_change: StateChangeBlock):
        """Permanently store a state change block."""
        self.state_changes.append(state_change)

        # Store in database first
        try:
            await self._persist_state_change(state_change)
            logger.debug(f"HistoryRecorder: Successfully persisted state change to database")
        except Exception as e:
            logger.error(f"HistoryRecorder: Failed to persist state change to database: {e}")

        # Store as JSON file for training/analysis (best effort)
        try:
            await self._store_state_change_file(state_change)
        except Exception as e:
            logger.warning(f"HistoryRecorder: Failed to store state change file: {e}")

        # Maintain memory limit
        if len(self.state_changes) > 10000:
            self.state_changes = self.state_changes[-10000:]

    async def _persist_state_change(self, state_change: StateChangeBlock):
        """Store state change in database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Ensure state_changes table exists
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Table ensured for database: {self.db_path}")

                # Store the state change
                await db.execute(
                    """
                    INSERT INTO state_changes (
                        timestamp, change_type, source, channel_id,
                        observations, potential_actions, selected_actions,
                        reasoning, raw_content
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        state_change.timestamp,
                        state_change.change_type,
                        state_change.source,
                        state_change.channel_id,
                        state_change.observations,
                        json.dumps(state_change.potential_actions) if state_change.potential_actions else None,
                        json.dumps(state_change.selected_actions) if state_change.selected_actions else None,
                        state_change.reasoning,
                        json.dumps(state_change.raw_content),
                    ),
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Successfully inserted state change into database")

        except Exception as e:
            logger.error(f"HistoryRecorder: Error persisting state change: {e}")
            raise  # Re-raise to let caller handle

    async def _store_state_change_file(self, state_change: StateChangeBlock):
        """Store state change as JSON file for analysis."""
        try:
            timestamp_str = time.strftime("%Y%m%d_%H%M%S", time.localtime(state_change.timestamp))
            filename = f"state_change_{timestamp_str}_{state_change.change_type}_{state_change.source}.json"
            file_path = self.storage_path / filename

            # Convert to dict for JSON serialization
            state_dict = asdict(state_change)

            with open(file_path, "w") as f:
                json.dump(state_dict, f, indent=2, default=str)

            logger.debug(f"HistoryRecorder: Stored state change file: {filename}")

        except Exception as e:
            logger.error(f"HistoryRecorder: Error storing state change file: {e}")

    async def get_recent_state_changes(
        self, 
        limit: int = 100, 
        change_type: Optional[str] = None,
        channel_id: Optional[str] = None
    ) -> List[StateChangeBlock]:
        """Retrieve recent state changes from database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Ensure table exists before querying
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                
                query = """
                    SELECT timestamp, change_type, source, channel_id,
                           observations, potential_actions, selected_actions,
                           reasoning, raw_content
                    FROM state_changes
                """
                params = []
                
                conditions = []
                if change_type:
                    conditions.append("change_type = ?")
                    params.append(change_type)
                
                if channel_id:
                    conditions.append("channel_id = ?")
                    params.append(channel_id)
                
                if conditions:
                    query += " WHERE " + " AND ".join(conditions)
                
                query += " ORDER BY timestamp DESC LIMIT ?"
                params.append(limit)

                async with db.execute(query, params) as cursor:
                    rows = await cursor.fetchall()

                state_changes = []
                for row in rows:
                    state_change = StateChangeBlock(
                        timestamp=row[0],
                        change_type=row[1],
                        source=row[2],
                        channel_id=row[3],
                        observations=row[4],
                        potential_actions=json.loads(row[5]) if row[5] else None,
                        selected_actions=json.loads(row[6]) if row[6] else None,
                        reasoning=row[7],
                        raw_content=json.loads(row[8])
                    )
                    state_changes.append(state_change)

                return state_changes

        except Exception as e:
            logger.error(f"HistoryRecorder: Error retrieving state changes: {e}")
            return []

    async def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about recorded state changes."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Get total count
                async with db.execute("SELECT COUNT(*) FROM state_changes") as cursor:
                    total_count = (await cursor.fetchone())[0]

                # Get counts by type
                async with db.execute("""
                    SELECT change_type, COUNT(*) 
                    FROM state_changes 
                    GROUP BY change_type
                """) as cursor:
                    type_counts = dict(await cursor.fetchall())

                # Get counts by source
                async with db.execute("""
                    SELECT source, COUNT(*) 
                    FROM state_changes 
                    GROUP BY source
                """) as cursor:
                    source_counts = dict(await cursor.fetchall())

                # Get recent activity (last 24 hours)
                twenty_four_hours_ago = time.time() - (24 * 3600)
                async with db.execute("""
                    SELECT COUNT(*) 
                    FROM state_changes 
                    WHERE timestamp > ?
                """, (twenty_four_hours_ago,)) as cursor:
                    recent_count = (await cursor.fetchone())[0]

                return {
                    "total_records": total_count,
                    "total_state_changes": total_count,  # Keep for backward compatibility
                    "changes_by_type": type_counts,
                    "changes_by_source": source_counts,
                    "recent_activity_24h": recent_count,
                    "in_memory_count": len(self.state_changes)
                }

        except Exception as e:
            logger.error(f"HistoryRecorder: Error getting statistics: {e}")
            return {}

    async def cleanup_old_records(self, days_to_keep: int = 30):
        """Remove old state change records."""
        try:
            cutoff_time = time.time() - (days_to_keep * 24 * 3600)
            
            async with aiosqlite.connect(self.db_path) as db:
                # Delete old records
                await db.execute("""
                    DELETE FROM state_changes 
                    WHERE timestamp < ?
                """, (cutoff_time,))
                
                deleted_count = db.total_changes
                await db.commit()
                
                logger.info(f"HistoryRecorder: Cleaned up {deleted_count} old records")
                return deleted_count

        except Exception as e:
            logger.error(f"HistoryRecorder: Error cleaning up old records: {e}")
            return 0

    async def export_state_changes_for_training(
        self, output_path: str, format: str = "jsonl"
    ) -> str:
        """
        Export state changes for training or analysis.
        
        Args:
            output_path: Path where to save the exported data
            format: Export format ('jsonl' or 'json')
            
        Returns:
            Status message about the export
        """
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Get all state changes ordered by timestamp
                async with db.execute("""
                    SELECT timestamp, change_type, source, channel_id, 
                           observations, potential_actions, selected_actions, 
                           reasoning, raw_content
                    FROM state_changes 
                    ORDER BY timestamp ASC
                """) as cursor:
                    records = await cursor.fetchall()

            if not records:
                return "No state changes found to export"

            # Prepare data for export
            export_data = []
            for record in records:
                timestamp, change_type, source, channel_id, observations, potential_actions, selected_actions, reasoning, raw_content = record
                
                # Parse JSON fields
                try:
                    potential_actions = json.loads(potential_actions) if potential_actions else None
                    selected_actions = json.loads(selected_actions) if selected_actions else None
                    raw_content = json.loads(raw_content) if raw_content else {}
                except json.JSONDecodeError:
                    logger.warning(f"Failed to parse JSON for record at {timestamp}")
                    continue

                export_record = {
                    "timestamp": timestamp,
                    "change_type": change_type,
                    "source": source,
                    "channel_id": channel_id,
                    "observations": observations,
                    "potential_actions": potential_actions,
                    "selected_actions": selected_actions,
                    "reasoning": reasoning,
                    "raw_content": raw_content
                }
                export_data.append(export_record)

            # Write to file
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)

            if format.lower() == "jsonl":
                with open(output_file, 'w', encoding='utf-8') as f:
                    for record in export_data:
                        f.write(json.dumps(record, ensure_ascii=False) + '\n')
            else:  # JSON format
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)

            message = f"Exported {len(export_data)} state changes to {output_path}"
            logger.info(f"HistoryRecorder: {message}")
            return message

        except Exception as e:
            error_msg = f"Error exporting state changes: {e}"
            logger.error(f"HistoryRecorder: {error_msg}")
            return error_msg

    async def initialize_memory_tables(self):
        """Initialize memory-related database tables."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # User memories table
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS user_memories (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_platform_id TEXT NOT NULL,
                        memory_id TEXT UNIQUE NOT NULL,
                        timestamp REAL NOT NULL,
                        content TEXT NOT NULL,
                        source_message_id TEXT,
                        source_cast_hash TEXT,
                        related_entities TEXT,
                        memory_type TEXT DEFAULT 'observation',
                        importance REAL DEFAULT 0.5,
                        ai_summary TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                
                # Research database table  
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS research_entries (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        topic TEXT UNIQUE NOT NULL,
                        title TEXT NOT NULL,
                        content TEXT NOT NULL,
                        source_url TEXT,
                        confidence_level INTEGER DEFAULT 5,
                        last_updated REAL NOT NULL,
                        last_verified REAL,
                        tags TEXT,
                        related_topics TEXT,
                        verification_notes TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                
                await db.commit()
                logger.info("HistoryRecorder: Memory persistence tables initialized")
                
        except Exception as e:
            logger.error(f"HistoryRecorder: Error initializing memory tables: {e}")

    async def store_user_memory(self, memory_entry) -> bool:
        """
        Store a user memory entry persistently.
        
        Args:
            memory_entry: MemoryEntry object from world state structures
            
        Returns:
            bool: True if successfully stored, False otherwise
        """
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """
                    INSERT OR REPLACE INTO user_memories (
                        user_platform_id, memory_id, timestamp, content,
                        source_message_id, source_cast_hash, related_entities,
                        memory_type, importance, ai_summary, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        memory_entry.user_platform_id,
                        memory_entry.memory_id,
                        memory_entry.timestamp,
                        memory_entry.content,
                        memory_entry.source_message_id,
                        memory_entry.source_cast_hash,
                        json.dumps(memory_entry.related_entities),
                        memory_entry.memory_type,
                        memory_entry.importance,
                        memory_entry.ai_summary,
                        time.time()
                    )
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Stored memory for user {memory_entry.user_platform_id}")
                return True
                
        except Exception as e:
            logger.error(f"HistoryRecorder: Error storing user memory: {e}")
            return False

    async def load_user_memories(self, user_platform_id: str, limit: int = 100):
        """
        Load user memories from persistent storage.
        
        Args:
            user_platform_id: Platform-specific user identifier
            limit: Maximum number of memories to load
            
        Returns:
            List of MemoryEntry objects
        """
        try:
            from .world_state.structures import MemoryEntry
            
            async with aiosqlite.connect(self.db_path) as db:
                async with db.execute(
                    """
                    SELECT user_platform_id, memory_id, timestamp, content,
                           source_message_id, source_cast_hash, related_entities,
                           memory_type, importance, ai_summary
                    FROM user_memories 
                    WHERE user_platform_id = ?
                    ORDER BY timestamp DESC
                    LIMIT ?
                    """,
                    (user_platform_id, limit)
                ) as cursor:
                    rows = await cursor.fetchall()
                    
                memories = []
                for row in rows:
                    related_entities = json.loads(row[6]) if row[6] else []
                    
                    memory = MemoryEntry(
                        user_platform_id=row[0],
                        memory_id=row[1],
                        timestamp=row[2],
                        content=row[3],
                        source_message_id=row[4],
                        source_cast_hash=row[5],
                        related_entities=related_entities,
                        memory_type=row[7],
                        importance=row[8],
                        ai_summary=row[9]
                    )
                    memories.append(memory)
                    
                logger.debug(f"HistoryRecorder: Loaded {len(memories)} memories for user {user_platform_id}")
                return memories
                
        except Exception as e:
            logger.error(f"HistoryRecorder: Error loading user memories: {e}")
            return []

    async def store_research_entry(self, topic: str, research_data: dict) -> bool:
        """
        Store a research entry persistently.
        
        Args:
            topic: Research topic key
            research_data: Dictionary containing research information
            
        Returns:
            bool: True if successfully stored, False otherwise
        """
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """
                    INSERT OR REPLACE INTO research_entries (
                        topic, title, content, source_url, confidence_level,
                        last_updated, last_verified, tags, related_topics,
                        verification_notes
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        topic,
                        research_data.get('title', ''),
                        research_data.get('content', ''),
                        research_data.get('source_url'),
                        research_data.get('confidence_level', 5),
                        research_data.get('last_updated', time.time()),
                        research_data.get('last_verified'),
                        json.dumps(research_data.get('tags', [])),
                        json.dumps(research_data.get('related_topics', [])),
                        research_data.get('verification_notes')
                    )
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Stored research entry for topic: {topic}")
                return True
                
        except Exception as e:
            logger.error(f"HistoryRecorder: Error storing research entry: {e}")
            return False

    async def load_research_entries(self, limit: int = 1000) -> dict:
        """
        Load research entries from persistent storage.
        
        Args:
            limit: Maximum number of entries to load
            
        Returns:
            Dictionary of topic -> research_data
        """
        try:
            async with aiosqlite.connect(self.db_path) as db:
                async with db.execute(
                    """
                    SELECT topic, title, content, source_url, confidence_level,
                           last_updated, last_verified, tags, related_topics,
                           verification_notes
                    FROM research_entries
                    ORDER BY last_updated DESC
                    LIMIT ?
                    """,
                    (limit,)
                ) as cursor:
                    rows = await cursor.fetchall()
                    
                research_database = {}
                for row in rows:
                    topic = row[0]
                    tags = json.loads(row[7]) if row[7] else []
                    related_topics = json.loads(row[8]) if row[8] else []
                    
                    research_data = {
                        'title': row[1],
                        'content': row[2],
                        'source_url': row[3],
                        'confidence_level': row[4],
                        'last_updated': row[5],
                        'last_verified': row[6],
                        'tags': tags,
                        'related_topics': related_topics,
                        'verification_notes': row[9]
                    }
                    research_database[topic] = research_data
                    
                logger.debug(f"HistoryRecorder: Loaded {len(research_database)} research entries")
                return research_database
                
        except Exception as e:
            logger.error(f"HistoryRecorder: Error loading research entries: {e}")
            return {}

    async def export_for_training(self, output_path: str, format: str = "jsonl") -> str:
        """Export state changes for training purposes."""
        return await self.export_state_changes_for_training(output_path, format)
