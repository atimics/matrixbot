"""
History Recorder

Focused module for recording and persisting StateChangeBlock instances.
This module handles the persistence layer for conversation context and state changes,
providing a clean interface for storing bot actions and decisions for later analysis.
"""

import asyncio
import json
import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional

import aiosqlite

logger = logging.getLogger(__name__)


@dataclass
class StateChangeBlock:
    """Represents a valid state change generated by the LLM or tools"""

    timestamp: float
    change_type: str  # 'llm_observation', 'tool_execution', 'user_input', 'world_update'
    source: str  # 'llm', 'tool_name', 'user', 'system'
    channel_id: Optional[str]
    observations: Optional[str]
    potential_actions: Optional[List[Dict[str, Any]]]
    selected_actions: Optional[List[Dict[str, Any]]]
    reasoning: Optional[str]
    raw_content: Dict[str, Any]  # Original content for training


class HistoryRecorder:
    """
    Records and persists StateChangeBlock instances for analysis and training.
    
    This class provides a focused interface for:
    1. Recording bot actions and decisions
    2. Persisting state changes to database and files
    3. Retrieving historical records for analysis
    4. Managing storage limits and cleanup
    """

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.state_changes: List[StateChangeBlock] = []

        # Initialize storage directory
        self.storage_path = Path("context_storage")
        self.storage_path.mkdir(exist_ok=True)

        logger.info("HistoryRecorder: Initialized")

    async def initialize(self):
        """Initialize the database and ensure tables exist."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                await db.commit()
                logger.info("HistoryRecorder: Database initialized")
        except Exception as e:
            logger.error(f"HistoryRecorder: Error initializing database: {e}")

    async def record_action(self, action_name: str, action_data: Dict[str, Any], result: Any):
        """Record a tool action execution."""
        observation_str = f"Tool '{action_name}' executed with params {action_data}. Result: {result}"
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="tool_execution",  # Consistent with test_record_tool_execution expectation after fix
            source="tool", # Changed from action_name to "tool"
            channel_id=action_data.get("channel_id"),
            observations=observation_str, # Populated observations
            potential_actions=None,
            selected_actions=[action_data],
            reasoning=f"Executed {action_name}",
            raw_content={
                "action": action_data,
                "result": str(result) if result else None,
                "tool_name": action_name
            }
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded action {action_name}")

    async def record_decision(
        self,
        channel_id: str,
        observations: str,
        potential_actions: List[Dict[str, Any]],
        selected_actions: List[Dict[str, Any]],
        reasoning: str,
        raw_llm_response: Dict[str, Any]
    ):
        """Record an AI decision with observations and selected actions."""
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="llm_observation", # Test expects "bot_decision", will adjust test
            source="llm",
            channel_id=channel_id,
            observations=observations,
            potential_actions=potential_actions,
            selected_actions=selected_actions,
            reasoning=reasoning,
            raw_content=raw_llm_response
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded AI decision for {channel_id}")

    async def record_user_input(self, channel_id: Optional[str], user_data: Dict[str, Any]):
        """Record user input to the system."""
        if not isinstance(user_data, dict):
            raise TypeError("user_data must be a dictionary.")
        if not user_data: # Check if dict is empty
            raise ValueError("user_data cannot be empty.")

        # Attempt to extract a meaningful observation from common message structures
        observed_text = ""
        if "content" in user_data and isinstance(user_data["content"], dict):
            if "body" in user_data["content"]: # For Matrix-like messages
                observed_text = str(user_data["content"]["body"])
            elif "text" in user_data["content"]: # For other common structures
                observed_text = str(user_data["content"]["text"])
        elif "message" in user_data: # Simpler structure
             observed_text = str(user_data["message"])
        elif "text" in user_data:
             observed_text = str(user_data["text"])
        else: # Fallback if no common structure found
            observed_text = json.dumps(user_data)


        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="user_input",
            source="user",
            channel_id=channel_id,
            observations=observed_text, # Populated observations
            potential_actions=None,
            selected_actions=None,
            reasoning="User input received",
            raw_content=user_data
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded user input for {channel_id}")

    async def record_world_update(self, update_type: str, update_data: Dict[str, Any]):
        """Record a world state update."""
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="world_update",
            source="system",
            channel_id=None,
            observations=None,
            potential_actions=None,
            selected_actions=None,
            reasoning=f"World state update: {update_type}",
            raw_content=update_data
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded world update: {update_type}")

    async def record_tool_execution( # This method is distinct from record_action
        self,
        tool_name: str,
        tool_params: Dict[str, Any],
        tool_result: Dict[str, Any],
        channel_id: Optional[str] = None
    ):
        """Record the execution of a tool/action."""
        observation_str = f"Tool \'{tool_name}\' executed with params {tool_params}. Result: {tool_result}"
        state_change = StateChangeBlock(
            timestamp=time.time(),
            change_type="tool_execution", 
            source="system", # This is different from record_action's "tool"
            channel_id=channel_id,
            observations=observation_str, # Populated observations
            potential_actions=None,
            selected_actions=[{
                "tool": tool_name,
                "parameters": tool_params,
                "result": tool_result
            }],
            reasoning=f"Tool execution: {tool_name}",
            raw_content={
                "tool_name": tool_name,
                "parameters": tool_params,
                "result": tool_result
            }
        )
        
        await self._store_state_change(state_change)
        logger.debug(f"HistoryRecorder: Recorded tool execution {tool_name}")

    async def _store_state_change(self, state_change: StateChangeBlock):
        """Permanently store a state change block."""
        self.state_changes.append(state_change)

        # Store in database first
        try:
            await self._persist_state_change(state_change)
            logger.debug(f"HistoryRecorder: Successfully persisted state change to database")
        except Exception as e:
            logger.error(f"HistoryRecorder: Failed to persist state change to database: {e}")

        # Store as JSON file for training/analysis (best effort)
        try:
            await self._store_state_change_file(state_change)
        except Exception as e:
            logger.warning(f"HistoryRecorder: Failed to store state change file: {e}")

        # Maintain memory limit
        if len(self.state_changes) > 10000:
            self.state_changes = self.state_changes[-10000:]

    async def _persist_state_change(self, state_change: StateChangeBlock):
        """Store state change in database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Ensure state_changes table exists
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Table ensured for database: {self.db_path}")

                # Store the state change
                await db.execute(
                    """
                    INSERT INTO state_changes (
                        timestamp, change_type, source, channel_id,
                        observations, potential_actions, selected_actions,
                        reasoning, raw_content
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        state_change.timestamp,
                        state_change.change_type,
                        state_change.source,
                        state_change.channel_id,
                        state_change.observations,
                        json.dumps(state_change.potential_actions) if state_change.potential_actions else None,
                        json.dumps(state_change.selected_actions) if state_change.selected_actions else None,
                        state_change.reasoning,
                        json.dumps(state_change.raw_content),
                    ),
                )
                await db.commit()
                logger.debug(f"HistoryRecorder: Successfully inserted state change into database")

        except Exception as e:
            logger.error(f"HistoryRecorder: Error persisting state change: {e}")
            raise  # Re-raise to let caller handle

    async def _store_state_change_file(self, state_change: StateChangeBlock):
        """Store state change as JSON file for analysis."""
        try:
            timestamp_str = time.strftime("%Y%m%d_%H%M%S", time.localtime(state_change.timestamp))
            filename = f"state_change_{timestamp_str}_{state_change.change_type}_{state_change.source}.json"
            file_path = self.storage_path / filename

            # Convert to dict for JSON serialization
            state_dict = asdict(state_change)

            with open(file_path, "w") as f:
                json.dump(state_dict, f, indent=2, default=str)

            logger.debug(f"HistoryRecorder: Stored state change file: {filename}")

        except Exception as e:
            logger.error(f"HistoryRecorder: Error storing state change file: {e}")

    async def get_recent_state_changes(
        self, 
        limit: int = 100, 
        change_type: Optional[str] = None,
        channel_id: Optional[str] = None
    ) -> List[StateChangeBlock]:
        """Retrieve recent state changes from database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Ensure table exists before querying
                await db.execute(
                    """
                    CREATE TABLE IF NOT EXISTS state_changes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp REAL NOT NULL,
                        change_type TEXT NOT NULL,
                        source TEXT NOT NULL,
                        channel_id TEXT,
                        observations TEXT,
                        potential_actions TEXT,
                        selected_actions TEXT,
                        reasoning TEXT,
                        raw_content TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                
                query = """
                    SELECT timestamp, change_type, source, channel_id,
                           observations, potential_actions, selected_actions,
                           reasoning, raw_content
                    FROM state_changes
                """
                params = []
                
                conditions = []
                if change_type:
                    conditions.append("change_type = ?")
                    params.append(change_type)
                
                if channel_id:
                    conditions.append("channel_id = ?")
                    params.append(channel_id)
                
                if conditions:
                    query += " WHERE " + " AND ".join(conditions)
                
                query += " ORDER BY timestamp DESC LIMIT ?"
                params.append(limit)

                async with db.execute(query, params) as cursor:
                    rows = await cursor.fetchall()

                state_changes = []
                for row in rows:
                    state_change = StateChangeBlock(
                        timestamp=row[0],
                        change_type=row[1],
                        source=row[2],
                        channel_id=row[3],
                        observations=row[4],
                        potential_actions=json.loads(row[5]) if row[5] else None,
                        selected_actions=json.loads(row[6]) if row[6] else None,
                        reasoning=row[7],
                        raw_content=json.loads(row[8])
                    )
                    state_changes.append(state_change)

                return state_changes

        except Exception as e:
            logger.error(f"HistoryRecorder: Error retrieving state changes: {e}")
            return []

    async def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about recorded state changes."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Get total count
                async with db.execute("SELECT COUNT(*) FROM state_changes") as cursor:
                    total_count = (await cursor.fetchone())[0]

                # Get counts by type
                async with db.execute("""
                    SELECT change_type, COUNT(*) 
                    FROM state_changes 
                    GROUP BY change_type
                """) as cursor:
                    type_counts = dict(await cursor.fetchall())

                # Get counts by source
                async with db.execute("""
                    SELECT source, COUNT(*) 
                    FROM state_changes 
                    GROUP BY source
                """) as cursor:
                    source_counts = dict(await cursor.fetchall())

                # Get recent activity (last 24 hours)
                twenty_four_hours_ago = time.time() - (24 * 3600)
                async with db.execute("""
                    SELECT COUNT(*) 
                    FROM state_changes 
                    WHERE timestamp > ?
                """, (twenty_four_hours_ago,)) as cursor:
                    recent_count = (await cursor.fetchone())[0]

                return {
                    "total_records": total_count,
                    "total_state_changes": total_count,  # Keep for backward compatibility
                    "changes_by_type": type_counts,
                    "changes_by_source": source_counts,
                    "recent_activity_24h": recent_count,
                    "in_memory_count": len(self.state_changes)
                }

        except Exception as e:
            logger.error(f"HistoryRecorder: Error getting statistics: {e}")
            return {}

    async def cleanup_old_records(self, days_to_keep: int = 30):
        """Remove old state change records."""
        try:
            cutoff_time = time.time() - (days_to_keep * 24 * 3600)
            
            async with aiosqlite.connect(self.db_path) as db:
                # Delete old records
                await db.execute("""
                    DELETE FROM state_changes 
                    WHERE timestamp < ?
                """, (cutoff_time,))
                
                deleted_count = db.total_changes
                await db.commit()
                
                logger.info(f"HistoryRecorder: Cleaned up {deleted_count} old records")
                return deleted_count

        except Exception as e:
            logger.error(f"HistoryRecorder: Error cleaning up old records: {e}")
            return 0
