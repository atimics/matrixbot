"""
Proactive Conversation Tools

Tools that enable the AI to proactively manage conversations and engage users.
Part of Initiative C: Proactive Conversation Management.
"""

import logging
from typing import Any, Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta

from .base import ToolInterface, ActionContext

logger = logging.getLogger(__name__)


@dataclass
class ProactiveEngagementPlan:
    """Represents a proactive engagement plan generated by the engine."""
    opportunity_id: str
    opportunity_type: str
    channel_id: str
    priority_score: float
    actions: List[Dict[str, Any]]
    timing_preference: str
    success_metrics: Dict[str, Any]
    confidence_score: float
    context: Dict[str, Any]


class InitiateProactiveConversationTool(ToolInterface):
    """
    Tool for AI to initiate proactive conversations based on detected opportunities.
    
    This tool allows the AI to start conversations proactively when it identifies
    opportunities for engagement, such as trending topics, user milestones, or
    quiet channels needing re-engagement.
    """
    
    @property
    def name(self) -> str:
        return "initiate_proactive_conversation"
    
    @property 
    def description(self) -> str:
        return "Initiate a proactive conversation based on detected opportunities"
    
    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "opportunity_type": {
                    "type": "string",
                    "description": "Type of opportunity detected",
                    "enum": [
                        "trending_topic",
                        "user_milestone", 
                        "quiet_channel",
                        "follow_up",
                        "cross_platform_bridge",
                        "community_engagement"
                    ]
                },
                "channel_id": {
                    "type": "string",
                    "description": "Channel ID where the conversation should be initiated"
                },
                "engagement_strategy": {
                    "type": "string",
                    "description": "Strategy to use for engagement",
                    "enum": [
                        "trending_topic_discussion",
                        "milestone_celebration",
                        "channel_reactivation",
                        "new_user_welcome",
                        "cross_platform_bridge",
                        "content_sharing"
                    ]
                },
                "message_content": {
                    "type": "string",
                    "description": "The message content to initiate the conversation"
                },
                "context_data": {
                    "type": "object",
                    "description": "Additional context data for the engagement",
                    "properties": {
                        "user_fids": {
                            "type": "array",
                            "items": {"type": "integer"},
                            "description": "User FIDs relevant to this engagement"
                        },
                        "topic_keywords": {
                            "type": "array", 
                            "items": {"type": "string"},
                            "description": "Keywords related to the topic"
                        },
                        "reference_urls": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "URLs to reference in the conversation"
                        },
                        "timing_sensitivity": {
                            "type": "string",
                            "description": "How time-sensitive this engagement is",
                            "enum": ["immediate", "within_hour", "within_day", "flexible"]
                        }
                    }
                }
            },
            "required": ["opportunity_type", "channel_id", "engagement_strategy", "message_content"]
        }
    
    async def execute(self, params: Dict[str, Any], context: ActionContext) -> Dict[str, Any]:
        """Execute proactive conversation initiation."""
        try:
            opportunity_type = params.get("opportunity_type")
            channel_id = params.get("channel_id")
            engagement_strategy = params.get("engagement_strategy")
            message_content = params.get("message_content")
            context_data = params.get("context_data", {})
            
            logger.info(f"Initiating proactive conversation: {opportunity_type} in {channel_id}")
            
            # Get the proactive conversation engine from world state
            if hasattr(context.world_state_manager, 'proactive_engine'):
                proactive_engine = context.world_state_manager.proactive_engine
                
                # Create engagement plan
                engagement_plan = ProactiveEngagementPlan(
                    opportunity_id=f"{opportunity_type}_{channel_id}_{int(datetime.now().timestamp())}",
                    opportunity_type=opportunity_type,
                    channel_id=channel_id,
                    priority_score=0.8,  # Default high priority for AI-initiated
                    actions=[{
                        "type": "send_message",
                        "content": message_content,
                        "strategy": engagement_strategy
                    }],
                    timing_preference=context_data.get("timing_sensitivity", "immediate"),
                    success_metrics={
                        "target_responses": 1,
                        "target_engagement_time": 300  # 5 minutes
                    },
                    confidence_score=0.9,  # High confidence for AI-initiated
                    context=context_data
                )
                
                # Execute the engagement plan
                success = await proactive_engine.execute_engagement_plan(engagement_plan)
                
                if success:
                    # Track the proactive engagement
                    await proactive_engine.track_engagement_outcome(
                        engagement_plan.opportunity_id,
                        "initiated",
                        {"initiated_at": datetime.now().isoformat()}
                    )
                    
                    return {
                        "status": "success",
                        "message": f"Proactive conversation initiated successfully",
                        "opportunity_id": engagement_plan.opportunity_id,
                        "channel_id": channel_id,
                        "strategy": engagement_strategy
                    }
                else:
                    return {
                        "status": "error",
                        "message": "Failed to execute engagement plan"
                    }
            else:
                return {
                    "status": "error", 
                    "message": "Proactive conversation engine not available"
                }
                
        except Exception as e:
            logger.error(f"Error initiating proactive conversation: {e}")
            return {
                "status": "error",
                "message": f"Error initiating proactive conversation: {str(e)}"
            }


class DetectConversationOpportunitiesTool(ToolInterface):
    """
    Tool for AI to detect conversation opportunities in the current context.
    
    This tool analyzes the current world state and context to identify potential
    opportunities for proactive engagement.
    """
    
    def __init__(self):
        super().__init__(
            name="detect_conversation_opportunities",
            description="Detect potential opportunities for proactive conversation engagement",
            parameters={
                "type": "object", 
                "properties": {
                    "analysis_scope": {
                        "type": "string",
                        "description": "Scope of analysis for opportunity detection",
                        "enum": ["current_context", "recent_activity", "cross_platform", "comprehensive"],
                        "default": "current_context"
                    },
                    "opportunity_types": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "trending_topic",
                                "user_milestone",
                                "quiet_channel", 
                                "follow_up",
                                "cross_platform_bridge",
                                "community_engagement"
                            ]
                        },
                        "description": "Types of opportunities to look for"
                    },
                    "minimum_priority": {
                        "type": "number",
                        "description": "Minimum priority score for opportunities (0.0-1.0)",
                        "minimum": 0.0,
                        "maximum": 1.0,
                        "default": 0.5
                    },
                    "max_opportunities": {
                        "type": "integer",
                        "description": "Maximum number of opportunities to return",
                        "minimum": 1,
                        "maximum": 20,
                        "default": 5
                    }
                }
            }
        )
    
    async def execute(self, context: ActionContext, **kwargs) -> Dict[str, Any]:
        """Execute opportunity detection."""
        try:
            analysis_scope = kwargs.get("analysis_scope", "current_context")
            opportunity_types = kwargs.get("opportunity_types", [
                "trending_topic", "user_milestone", "quiet_channel", 
                "follow_up", "cross_platform_bridge", "community_engagement"
            ])
            minimum_priority = kwargs.get("minimum_priority", 0.5)
            max_opportunities = kwargs.get("max_opportunities", 5)
            
            logger.info(f"Detecting conversation opportunities with scope: {analysis_scope}")
            
            # Get the proactive conversation engine
            if hasattr(context.world_state_manager, 'proactive_engine'):
                proactive_engine = context.world_state_manager.proactive_engine
                
                # Detect opportunities based on current world state
                opportunities = await proactive_engine.detect_opportunities(
                    opportunity_types=opportunity_types,
                    minimum_priority=minimum_priority
                )
                
                # Filter and limit results
                filtered_opportunities = [
                    opp for opp in opportunities 
                    if opp.get("priority_score", 0) >= minimum_priority
                ][:max_opportunities]
                
                return {
                    "status": "success",
                    "opportunities_found": len(filtered_opportunities),
                    "opportunities": filtered_opportunities,
                    "analysis_scope": analysis_scope,
                    "detection_timestamp": datetime.now().isoformat()
                }
                
            else:
                return {
                    "status": "error",
                    "message": "Proactive conversation engine not available"
                }
                
        except Exception as e:
            logger.error(f"Error detecting conversation opportunities: {e}")
            return {
                "status": "error",
                "message": f"Error detecting opportunities: {str(e)}"
            }


class ScheduleProactiveEngagementTool(ToolInterface):
    """
    Tool for AI to schedule proactive engagements for future execution.
    
    This tool allows the AI to plan and schedule proactive conversations
    for optimal timing rather than immediate execution.
    """
    
    def __init__(self):
        super().__init__(
            name="schedule_proactive_engagement",
            description="Schedule a proactive engagement for future execution",
            parameters={
                "type": "object",
                "properties": {
                    "opportunity_id": {
                        "type": "string",
                        "description": "ID of the opportunity to schedule engagement for"
                    },
                    "engagement_strategy": {
                        "type": "string", 
                        "description": "Strategy to use for the engagement",
                        "enum": [
                            "trending_topic_discussion",
                            "milestone_celebration",
                            "channel_reactivation", 
                            "new_user_welcome",
                            "cross_platform_bridge",
                            "content_sharing"
                        ]
                    },
                    "scheduled_time": {
                        "type": "string",
                        "description": "ISO format timestamp for when to execute the engagement"
                    },
                    "message_template": {
                        "type": "string",
                        "description": "Message template for the engagement"
                    },
                    "priority_score": {
                        "type": "number",
                        "description": "Priority score for this engagement (0.0-1.0)",
                        "minimum": 0.0,
                        "maximum": 1.0,
                        "default": 0.5
                    },
                    "context_data": {
                        "type": "object",
                        "description": "Additional context data for the engagement"
                    }
                },
                "required": ["opportunity_id", "engagement_strategy", "scheduled_time", "message_template"]
            }
        )
    
    async def execute(self, context: ActionContext, **kwargs) -> Dict[str, Any]:
        """Execute engagement scheduling."""
        try:
            opportunity_id = kwargs.get("opportunity_id")
            engagement_strategy = kwargs.get("engagement_strategy")
            scheduled_time = kwargs.get("scheduled_time")
            message_template = kwargs.get("message_template")
            priority_score = kwargs.get("priority_score", 0.5)
            context_data = kwargs.get("context_data", {})
            
            logger.info(f"Scheduling proactive engagement: {opportunity_id} for {scheduled_time}")
            
            # Parse scheduled time
            try:
                scheduled_datetime = datetime.fromisoformat(scheduled_time.replace('Z', '+00:00'))
            except ValueError:
                return {
                    "status": "error",
                    "message": "Invalid scheduled_time format. Use ISO format."
                }
            
            # Validate scheduling time is in the future
            if scheduled_datetime <= datetime.now():
                return {
                    "status": "error", 
                    "message": "Scheduled time must be in the future"
                }
            
            # Get the proactive conversation engine
            if hasattr(context.world_state_manager, 'proactive_engine'):
                proactive_engine = context.world_state_manager.proactive_engine
                
                # Create scheduled engagement
                scheduled_engagement = {
                    "opportunity_id": opportunity_id,
                    "strategy": engagement_strategy,
                    "scheduled_time": scheduled_datetime.isoformat(),
                    "message_template": message_template,
                    "priority_score": priority_score,
                    "context_data": context_data,
                    "status": "scheduled",
                    "created_at": datetime.now().isoformat()
                }
                
                # Store the scheduled engagement
                success = await proactive_engine.schedule_engagement(scheduled_engagement)
                
                if success:
                    return {
                        "status": "success",
                        "message": "Engagement scheduled successfully",
                        "opportunity_id": opportunity_id,
                        "scheduled_time": scheduled_time,
                        "strategy": engagement_strategy
                    }
                else:
                    return {
                        "status": "error",
                        "message": "Failed to schedule engagement"
                    }
                    
            else:
                return {
                    "status": "error",
                    "message": "Proactive conversation engine not available"
                }
                
        except Exception as e:
            logger.error(f"Error scheduling proactive engagement: {e}")
            return {
                "status": "error",
                "message": f"Error scheduling engagement: {str(e)}"
            }


class GetProactiveEngagementStatusTool(ToolInterface):
    """
    Tool for AI to check the status of proactive engagements.
    
    This tool allows the AI to monitor the effectiveness and status
    of previously initiated proactive conversations.
    """
    
    def __init__(self):
        super().__init__(
            name="get_proactive_engagement_status", 
            description="Get status and metrics for proactive engagements",
            parameters={
                "type": "object",
                "properties": {
                    "opportunity_id": {
                        "type": "string",
                        "description": "Specific opportunity ID to check (optional)"
                    },
                    "time_range_hours": {
                        "type": "integer",
                        "description": "Hours back to check for engagements",
                        "minimum": 1,
                        "maximum": 168,  # 1 week
                        "default": 24
                    },
                    "include_metrics": {
                        "type": "boolean",
                        "description": "Whether to include detailed success metrics",
                        "default": True
                    },
                    "status_filter": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": ["scheduled", "initiated", "successful", "failed", "expired"]
                        },
                        "description": "Filter by engagement status"
                    }
                }
            }
        )
    
    async def execute(self, context: ActionContext, **kwargs) -> Dict[str, Any]:
        """Execute engagement status check."""
        try:
            opportunity_id = kwargs.get("opportunity_id")
            time_range_hours = kwargs.get("time_range_hours", 24)
            include_metrics = kwargs.get("include_metrics", True)
            status_filter = kwargs.get("status_filter", [])
            
            logger.info(f"Checking proactive engagement status for range: {time_range_hours}h")
            
            # Get the proactive conversation engine
            if hasattr(context.world_state_manager, 'proactive_engine'):
                proactive_engine = context.world_state_manager.proactive_engine
                
                # Get engagement status
                since_time = datetime.now() - timedelta(hours=time_range_hours)
                
                if opportunity_id:
                    # Get specific engagement status
                    engagement_status = await proactive_engine.get_engagement_status(opportunity_id)
                    if engagement_status:
                        return {
                            "status": "success",
                            "engagement": engagement_status,
                            "query_timestamp": datetime.now().isoformat()
                        }
                    else:
                        return {
                            "status": "not_found",
                            "message": f"Engagement {opportunity_id} not found"
                        }
                else:
                    # Get multiple engagements
                    engagements = await proactive_engine.get_recent_engagements(
                        since_time=since_time,
                        status_filter=status_filter,
                        include_metrics=include_metrics
                    )
                    
                    # Calculate summary statistics
                    total_engagements = len(engagements)
                    successful_engagements = len([
                        e for e in engagements 
                        if e.get("status") == "successful"
                    ])
                    success_rate = (successful_engagements / total_engagements * 100) if total_engagements > 0 else 0
                    
                    return {
                        "status": "success",
                        "total_engagements": total_engagements,
                        "successful_engagements": successful_engagements,
                        "success_rate": round(success_rate, 1),
                        "time_range_hours": time_range_hours,
                        "engagements": engagements,
                        "query_timestamp": datetime.now().isoformat()
                    }
                    
            else:
                return {
                    "status": "error",
                    "message": "Proactive conversation engine not available"
                }
                
        except Exception as e:
            logger.error(f"Error getting proactive engagement status: {e}")
            return {
                "status": "error", 
                "message": f"Error getting engagement status: {str(e)}"
            }
